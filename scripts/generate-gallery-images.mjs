/**
 * Build-time script: scans public/images/ and generates
 * src/data/generated/gallery-images.ts with all image paths.
 *
 * Usage: node scripts/generate-gallery-images.mjs
 */

import { readdirSync, readFileSync, writeFileSync } from "fs";
import { join, extname } from "path";

const ROOT = new URL("..", import.meta.url).pathname;
const IMAGES_DIR = join(ROOT, "public", "images");
const CATEGORIES_FILE = join(ROOT, "src", "data", "categories.ts");
const OUTPUT_FILE = join(ROOT, "src", "data", "generated", "gallery-images.ts");

const IMAGE_EXTS = new Set([".jpg", ".jpeg", ".png", ".webp"]);
const IGNORE_DIRS = new Set(["logo"]);

/**
 * Section images: directory name → alt text.
 * Each directory holds a single image used by the corresponding page section.
 * To add a new section image: add an entry here + create the directory.
 */
const SECTION_IMAGES = {
  hero: "ВМ-Торг — главное фото",
  philosophy: "Философия — мастерство в деталях",
};

/** Parse category titles from categories.ts via regex */
function parseCategoryTitles() {
  const src = readFileSync(CATEGORIES_FILE, "utf-8");
  const titles = {};
  const re = /id:\s*"([^"]+)"[\s\S]*?title:\s*"([^"]+)"/g;
  let m;
  while ((m = re.exec(src)) !== null) {
    titles[m[1]] = m[2];
  }
  return titles;
}

/** List image files in a directory (sorted, no dotfiles) */
function listImages(dir) {
  try {
    return readdirSync(dir)
      .filter((f) => !f.startsWith(".") && IMAGE_EXTS.has(extname(f).toLowerCase()))
      .sort();
  } catch {
    return [];
  }
}

// ── Gather data ──────────────────────────────────────────────

const titles = parseCategoryTitles();

const sectionDirs = new Set(Object.keys(SECTION_IMAGES));

// Gallery categories
const galleryEntries = [];
const dirs = readdirSync(IMAGES_DIR).filter(
  (d) => !IGNORE_DIRS.has(d) && !sectionDirs.has(d) && !d.startsWith("."),
);

for (const dir of dirs.sort()) {
  const files = listImages(join(IMAGES_DIR, dir));
  if (files.length === 0) continue;

  const title = titles[dir] ?? dir;
  const mainFile = files.find((f) => f.startsWith("main_"));
  const secondaryFiles = files.filter((f) => f !== mainFile);

  const mainImage = mainFile
    ? { src: `/images/${dir}/${mainFile}`, alt: title }
    : null;

  const secondaryImages = secondaryFiles.map((f, i) => ({
    src: `/images/${dir}/${f}`,
    alt: `${title} \u2014 ${i + 1}`,
  }));

  galleryEntries.push({ dir, mainImage, secondaryImages });
}

// Section images (hero, philosophy, etc.)
const sectionEntries = [];
for (const [dir, alt] of Object.entries(SECTION_IMAGES)) {
  const files = listImages(join(IMAGES_DIR, dir));
  const file = files[0] ?? null;
  if (file) {
    sectionEntries.push({ dir, src: `/images/${dir}/${file}`, alt });
  }
}

// ── Generate TypeScript ──────────────────────────────────────

/** Format a single image object inline */
function img(obj) {
  return `{ src: "${obj.src}", alt: "${obj.alt}" }`;
}

const lines = [
  "// Auto-generated by scripts/generate-gallery-images.mjs",
  "// Do not edit manually — run `npm run generate-gallery` to regenerate.",
  "",
  'import type { CategoryImage } from "@/types/category";',
  "",
  "interface GalleryEntry {",
  "  mainImage: CategoryImage | null;",
  "  secondaryImages: CategoryImage[];",
  "}",
  "",
  "export const galleryImages: Record<string, GalleryEntry> = {",
];

for (const { dir, mainImage, secondaryImages } of galleryEntries) {
  lines.push(`  "${dir}": {`);
  lines.push(`    mainImage: ${mainImage ? img(mainImage) : "null"},`);
  if (secondaryImages.length === 0) {
    lines.push("    secondaryImages: [],");
  } else {
    lines.push("    secondaryImages: [");
    for (const si of secondaryImages) {
      lines.push(`      ${img(si)},`);
    }
    lines.push("    ],");
  }
  lines.push("  },");
}

lines.push("};");
lines.push("");

lines.push("export const sectionImages: Record<string, CategoryImage> = {");
for (const { dir, src, alt } of sectionEntries) {
  lines.push(`  "${dir}": ${img({ src, alt })},`);
}
lines.push("};");
lines.push("");

writeFileSync(OUTPUT_FILE, lines.join("\n"));

// Format the generated file with Prettier
const { execSync } = await import("child_process");
execSync(`npx prettier --write "${OUTPUT_FILE}"`, {
  cwd: ROOT,
  stdio: "pipe",
});

console.log(`Generated ${OUTPUT_FILE}`);
const sectionList = sectionEntries.map((s) => s.dir).join(", ") || "(none)";
console.log(
  `  ${galleryEntries.length} categories, sections: ${sectionList}`,
);
